
riscv64_smc35x.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000012340000 <_start>:
#endif

		.section .text.entry
		.global _start
_start:
		lla		sp, stack_end
    12340000:	00000117          	auipc	sp,0x0
    12340004:	40010113          	addi	sp,sp,1024 # 12340400 <stack_end>
		jal 	flash_smc35x
    12340008:	0bc000ef          	jal	ra,123400c4 <flash_smc35x>
		ebreak
    1234000c:	00100073          	ebreak

0000000012340010 <smc35x_ecc_calculate>:
static uint32_t __attribute__((aligned(4))) NandOob32[6] = {26, 27, 28, 29, 30, 31};
static uint32_t __attribute__((aligned(4))) NandOob16[3] = {13, 14, 15};		/* data size 512bytes */


int smc35x_ecc_calculate(uint32_t ctrl_base, uint8_t *ecc_data, uint32_t ecc_data_nums)
{
    12340010:	ff010113          	addi	sp,sp,-16
	uint8_t count = 0, status = 0;
	volatile uint8_t ecc_reg = 0;
    12340014:	000107a3          	sb	zero,15(sp)
	uint32_t ecc_value = 0;
	void *ecc_addr = NULL, *status_addr = NULL;

	uint8_t nums = 0;
    12340018:	00000713          	li	a4,0
	while (ecc_data_nums >= 3) {
    1234001c:	00200793          	li	a5,2
    12340020:	02c7ec63          	bltu	a5,a2,12340058 <smc35x_ecc_calculate+0x48>
	}

	/* Check busy signal if it is busy to poll*/
	do {
		// target_read_u8(target, (ctrl_base + SMC_REG_ECC1_STATUS), &status);
        status_addr = (void *)(uintptr_t)(ctrl_base + SMC_REG_ECC1_STATUS);
    12340024:	02051513          	slli	a0,a0,0x20
    12340028:	02055513          	srli	a0,a0,0x20
		status = *(uint8_t *)status_addr;
    1234002c:	40054783          	lbu	a5,1024(a0)
		status &= (1 << SMC_EccStatus_EccStatus_FIELD);
    12340030:	0407f793          	andi	a5,a5,64
	}
	while (status);
    12340034:	00079063          	bnez	a5,12340034 <smc35x_ecc_calculate+0x24>

	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340038:	000107a3          	sb	zero,15(sp)
	{
		// target_read_u32(target, (ctrl_base + SMC_REG_ECC1_BLOCK0 + ecc_reg * 4), &ecc_value);
        ecc_addr = (void *)(uintptr_t)(ctrl_base + SMC_REG_ECC1_BLOCK0);
		ecc_value = *(uint32_t *)ecc_addr;
		// printf("ecc value: %lx", ecc_value);
		if((ecc_value) & (1 << SMC_EccBlock_ISCheakValueValid_FIELD))
    1234003c:	40000637          	lui	a2,0x40000
	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340040:	00f14783          	lbu	a5,15(sp)
    12340044:	0ff7f793          	zext.b	a5,a5
    12340048:	02e7e063          	bltu	a5,a4,12340068 <smc35x_ecc_calculate+0x58>
			// printf("EccInvalidErr");
			return SmcEccDataInvalidErr;
		}
	}

	return ERROR_OK;
    1234004c:	00000513          	li	a0,0
}
    12340050:	01010113          	addi	sp,sp,16
    12340054:	00008067          	ret
		++nums;
    12340058:	0017071b          	addiw	a4,a4,1
    1234005c:	0ff77713          	zext.b	a4,a4
		ecc_data_nums -= 3;
    12340060:	ffd6061b          	addiw	a2,a2,-3
    12340064:	fbdff06f          	j	12340020 <smc35x_ecc_calculate+0x10>
		ecc_value = *(uint32_t *)ecc_addr;
    12340068:	41852783          	lw	a5,1048(a0)
		if((ecc_value) & (1 << SMC_EccBlock_ISCheakValueValid_FIELD))
    1234006c:	00c7f6b3          	and	a3,a5,a2
    12340070:	0006869b          	sext.w	a3,a3
    12340074:	02068863          	beqz	a3,123400a4 <smc35x_ecc_calculate+0x94>
				*ecc_data = ecc_value & 0xFF;
    12340078:	00f58023          	sb	a5,0(a1)
				ecc_value = ecc_value >> 8;
    1234007c:	0087d69b          	srliw	a3,a5,0x8
    12340080:	0107d79b          	srliw	a5,a5,0x10
				*ecc_data = ecc_value & 0xFF;
    12340084:	00f58123          	sb	a5,2(a1)
	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340088:	00f14783          	lbu	a5,15(sp)
				*ecc_data = ecc_value & 0xFF;
    1234008c:	00d580a3          	sb	a3,1(a1)
				++ecc_data;
    12340090:	00358593          	addi	a1,a1,3
	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340094:	00178793          	addi	a5,a5,1
    12340098:	0ff7f793          	zext.b	a5,a5
    1234009c:	00f107a3          	sb	a5,15(sp)
    123400a0:	fa1ff06f          	j	12340040 <smc35x_ecc_calculate+0x30>
			return SmcEccDataInvalidErr;
    123400a4:	01000513          	li	a0,16
    123400a8:	fa9ff06f          	j	12340050 <smc35x_ecc_calculate+0x40>

00000000123400ac <nand_busy>:

uint8_t nand_busy(uint32_t ctrl_base)
{
	uint32_t status = *(volatile uint32_t *)(ctrl_base + SMC_REG_MEMC_STATUS);
    123400ac:	02051513          	slli	a0,a0,0x20
    123400b0:	02055513          	srli	a0,a0,0x20
    123400b4:	00052503          	lw	a0,0(a0)
	status &= (1 << SMC_MemcStatus_SmcInt1RawStatus_FIELD);

	if(status)
    123400b8:	00655513          	srli	a0,a0,0x6
		return NAND_READY;
	else
		return NAND_BUSY;
}
    123400bc:	00157513          	andi	a0,a0,1
    123400c0:	00008067          	ret

00000000123400c4 <flash_smc35x>:

int flash_smc35x(uint32_t ctrl_base, uint32_t page_size, void *pbuffer, uint32_t offset, uint32_t count, uint32_t nand_base, uint32_t ecc_num)
{
    123400c4:	f9010113          	addi	sp,sp,-112
    123400c8:	05313423          	sd	s3,72(sp)
    123400cc:	05413023          	sd	s4,64(sp)
    123400d0:	03513c23          	sd	s5,56(sp)
    123400d4:	00078993          	mv	s3,a5
    uint32_t oob_size = count - page_size;
	uint32_t eccDataNums = 0, *dataOffsetPtr = NULL;
	uint8_t eccData[12] = {0}, *buffer = pbuffer;
	void *status_addr = NULL;

	void *cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
    123400d8:	3807ea93          	ori	s5,a5,896
	uint32_t cmd_phase_data = -1;
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;

	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    123400dc:	00080a37          	lui	s4,0x80
	void *cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
    123400e0:	020a9a93          	slli	s5,s5,0x20
	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    123400e4:	0149ea33          	or	s4,s3,s4
{
    123400e8:	06113423          	sd	ra,104(sp)
    123400ec:	06813023          	sd	s0,96(sp)
    123400f0:	04913c23          	sd	s1,88(sp)
    123400f4:	05213823          	sd	s2,80(sp)
    123400f8:	03613823          	sd	s6,48(sp)
    123400fc:	03713423          	sd	s7,40(sp)
    12340100:	03813023          	sd	s8,32(sp)
    12340104:	01913c23          	sd	s9,24(sp)
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
    12340108:	fff00793          	li	a5,-1
	void *cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
    1234010c:	020ada93          	srli	s5,s5,0x20
	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    12340110:	020a1a13          	slli	s4,s4,0x20
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
    12340114:	00faa023          	sw	a5,0(s5)
	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    12340118:	020a5a13          	srli	s4,s4,0x20
	status = *(uint8_t *)data_phase_addr;
	if (!(status & ONFI_STATUS_WP)) {
    1234011c:	000a0783          	lb	a5,0(s4) # 80000 <_start-0x122c0000>
	uint8_t eccData[12] = {0}, *buffer = pbuffer;
    12340120:	00013023          	sd	zero,0(sp)
    12340124:	00012423          	sw	zero,8(sp)
	if (!(status & ONFI_STATUS_WP)) {
    12340128:	1807de63          	bgez	a5,123402c4 <flash_smc35x+0x200>
		return FAILED_FLAG;
	}

	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_PROGRAM_PAGE_CYCLES << 21) | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (ONFI_CMD_PROGRAM_PAGE1 << 3));
    1234012c:	00a087b7          	lui	a5,0xa08
    12340130:	40078793          	addi	a5,a5,1024 # a08400 <_start-0x11937c00>
    12340134:	00f9e7b3          	or	a5,s3,a5
	cmd_phase_data = 0 | (offset << (2*8));
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
	cmd_phase_data = offset >> (32 - (2*8));
    *(uint32_t *)cmd_phase_addr = cmd_phase_data;

	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340138:	00188c37          	lui	s8,0x188
	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_PROGRAM_PAGE_CYCLES << 21) | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (ONFI_CMD_PROGRAM_PAGE1 << 3));
    1234013c:	02079793          	slli	a5,a5,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340140:	0189ec33          	or	s8,s3,s8
	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_PROGRAM_PAGE_CYCLES << 21) | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (ONFI_CMD_PROGRAM_PAGE1 << 3));
    12340144:	0207d793          	srli	a5,a5,0x20
	cmd_phase_data = offset >> (32 - (2*8));
    12340148:	0106d69b          	srliw	a3,a3,0x10
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    1234014c:	020c1c13          	slli	s8,s8,0x20
    *(uint32_t *)cmd_phase_addr = cmd_phase_data;
    12340150:	00d7a023          	sw	a3,0(a5)
    12340154:	00050913          	mv	s2,a0
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340158:	020c5c13          	srli	s8,s8,0x20
	
	for (index = 0; index < page_size - ONFI_AXI_DATA_WIDTH; ++index)
    1234015c:	00000793          	li	a5,0
    12340160:	ffc5869b          	addiw	a3,a1,-4
    12340164:	0007851b          	sext.w	a0,a5
    12340168:	06d56c63          	bltu	a0,a3,123401e0 <flash_smc35x+0x11c>
		// 	retvel = *(uint8_t *)data_phase_addr;
		// 	++flag;
		// }
	}

	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (1 << 10));
    1234016c:	001887b7          	lui	a5,0x188
    12340170:	40078793          	addi	a5,a5,1024 # 188400 <_start-0x121b7c00>
    12340174:	00f9e7b3          	or	a5,s3,a5
	buffer += page_size - ONFI_AXI_DATA_WIDTH;
    12340178:	02069693          	slli	a3,a3,0x20
    1234017c:	0206d693          	srli	a3,a3,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (1 << 10));
    12340180:	02079793          	slli	a5,a5,0x20
	buffer += page_size - ONFI_AXI_DATA_WIDTH;
    12340184:	00d604b3          	add	s1,a2,a3
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (1 << 10));
    12340188:	0207d793          	srli	a5,a5,0x20
	buffer += page_size - ONFI_AXI_DATA_WIDTH;
    1234018c:	00000693          	li	a3,0
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    12340190:	00400613          	li	a2,4
	{
		// target_write_u8(target, data_phase_addr, data[index]);
        *(uint8_t *)data_phase_addr = buffer[index];
    12340194:	00d48533          	add	a0,s1,a3
    12340198:	00054503          	lbu	a0,0(a0)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    1234019c:	00168693          	addi	a3,a3,1
        *(uint8_t *)data_phase_addr = buffer[index];
    123401a0:	00a78023          	sb	a0,0(a5)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    123401a4:	fec698e3          	bne	a3,a2,12340194 <flash_smc35x+0xd0>
    uint32_t oob_size = count - page_size;
    123401a8:	40b7043b          	subw	s0,a4,a1
	}
    buffer += ONFI_AXI_DATA_WIDTH;

	switch(oob_size)
    123401ac:	04000793          	li	a5,64
    123401b0:	04f40663          	beq	s0,a5,123401fc <flash_smc35x+0x138>
    123401b4:	0487e063          	bltu	a5,s0,123401f4 <flash_smc35x+0x130>
    123401b8:	01000793          	li	a5,16
    123401bc:	10f40863          	beq	s0,a5,123402cc <flash_smc35x+0x208>
    123401c0:	02000793          	li	a5,32
    123401c4:	00000b97          	auipc	s7,0x0
    123401c8:	164b8b93          	addi	s7,s7,356 # 12340328 <NandOob32>
    123401cc:	00600b13          	li	s6,6
    123401d0:	10f40463          	beq	s0,a5,123402d8 <flash_smc35x+0x214>
		default:
			/* Page size 256 bytes & 4096 bytes not supported by ECC block */
			break;
	}
	if (ecc_num == 1 && dataOffsetPtr != NULL && eccDataNums != 0) {
		smc35x_ecc_calculate(ctrl_base, eccData, eccDataNums);
    123401d4:	00000793          	li	a5,0
			buffer[dataOffsetPtr[index]] = (~eccData[index]);
		}
	}

	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
	for (index = 0; index < oob_size - ONFI_AXI_DATA_WIDTH; ++index)
    123401d8:	ffc4041b          	addiw	s0,s0,-4
    123401dc:	0400006f          	j	1234021c <flash_smc35x+0x158>
        *(uint8_t *)data_phase_addr = buffer[index];
    123401e0:	00f60533          	add	a0,a2,a5
    123401e4:	00054503          	lbu	a0,0(a0)
    123401e8:	00178793          	addi	a5,a5,1
    123401ec:	00ac0023          	sb	a0,0(s8) # 188000 <_start-0x121b8000>
	for (index = 0; index < page_size - ONFI_AXI_DATA_WIDTH; ++index)
    123401f0:	f75ff06f          	j	12340164 <flash_smc35x+0xa0>
	switch(oob_size)
    123401f4:	0e000793          	li	a5,224
    123401f8:	fcf41ee3          	bne	s0,a5,123401d4 <flash_smc35x+0x110>
			dataOffsetPtr = NandOob64;
    123401fc:	00000b97          	auipc	s7,0x0
    12340200:	150b8b93          	addi	s7,s7,336 # 1234034c <NandOob64>
			eccDataNums = 12;
    12340204:	00c00b13          	li	s6,12
    12340208:	0d00006f          	j	123402d8 <flash_smc35x+0x214>
	{
		// target_write_u8(target, data_phase_addr, oob_data[index]);
        *(uint8_t *)data_phase_addr = buffer[index];
    1234020c:	00f48733          	add	a4,s1,a5
    12340210:	00474703          	lbu	a4,4(a4)
    12340214:	00178793          	addi	a5,a5,1
    12340218:	00ec0023          	sb	a4,0(s8)
	for (index = 0; index < oob_size - ONFI_AXI_DATA_WIDTH; ++index)
    1234021c:	0007871b          	sext.w	a4,a5
    12340220:	fe8766e3          	bltu	a4,s0,1234020c <flash_smc35x+0x148>
	}

	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 21) | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340224:	003887b7          	lui	a5,0x388
    12340228:	00f9e9b3          	or	s3,s3,a5
	buffer += oob_size - ONFI_AXI_DATA_WIDTH;
    1234022c:	02041413          	slli	s0,s0,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 21) | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340230:	02099993          	slli	s3,s3,0x20
	buffer += oob_size - ONFI_AXI_DATA_WIDTH;
    12340234:	02045413          	srli	s0,s0,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 21) | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340238:	0209d993          	srli	s3,s3,0x20
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    1234023c:	00848433          	add	s0,s1,s0
	buffer += oob_size - ONFI_AXI_DATA_WIDTH;
    12340240:	00400793          	li	a5,4
	{
		// target_write_u8(target, data_phase_addr, oob_data[index]);
        *(uint8_t *)data_phase_addr = buffer[index];
    12340244:	00444703          	lbu	a4,4(s0)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    12340248:	fff7879b          	addiw	a5,a5,-1
    1234024c:	00140413          	addi	s0,s0,1
        *(uint8_t *)data_phase_addr = buffer[index];
    12340250:	00e98023          	sb	a4,0(s3)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    12340254:	fe0798e3          	bnez	a5,12340244 <flash_smc35x+0x180>
	}


	while (nand_busy(ctrl_base) == NAND_BUSY);
    12340258:	00090513          	mv	a0,s2
    1234025c:	e51ff0ef          	jal	ra,123400ac <nand_busy>
    12340260:	fe050ce3          	beqz	a0,12340258 <flash_smc35x+0x194>


	/*  Clear SMC Interrupt 1, as an alternative to an AXI read */
    status_addr = (void *)(uintptr_t)(ctrl_base + SMC_REG_MEM_CFG_CLR);
    12340264:	02091913          	slli	s2,s2,0x20
    12340268:	02095913          	srli	s2,s2,0x20
	status = *(volatile uint32_t *)(ctrl_base + SMC_REG_MEM_CFG_CLR);
    1234026c:	00c92783          	lw	a5,12(s2)
    12340270:	0007879b          	sext.w	a5,a5
    *(volatile uint32_t *)status_addr = status | SMC_MemCfgClr_ClrSmcInt1;
    12340274:	0107e793          	ori	a5,a5,16
    12340278:	00f92623          	sw	a5,12(s2)


	/* Check Nand Status */
	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
	cmd_phase_data = -1;
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
    1234027c:	fff00793          	li	a5,-1
    12340280:	00faa023          	sw	a5,0(s5)

	data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
	status = *(uint8_t *)data_phase_addr;
	if (!(status & ONFI_STATUS_FAIL)) {
    12340284:	000a4503          	lbu	a0,0(s4)
    12340288:	00157513          	andi	a0,a0,1
    1234028c:	00154513          	xori	a0,a0,1
		return FAILED_FLAG;
	}

	return retvel;
    12340290:	06813083          	ld	ra,104(sp)
    12340294:	06013403          	ld	s0,96(sp)
    12340298:	05813483          	ld	s1,88(sp)
    1234029c:	05013903          	ld	s2,80(sp)
    123402a0:	04813983          	ld	s3,72(sp)
    123402a4:	04013a03          	ld	s4,64(sp)
    123402a8:	03813a83          	ld	s5,56(sp)
    123402ac:	03013b03          	ld	s6,48(sp)
    123402b0:	02813b83          	ld	s7,40(sp)
    123402b4:	02013c03          	ld	s8,32(sp)
    123402b8:	01813c83          	ld	s9,24(sp)
    123402bc:	07010113          	addi	sp,sp,112
    123402c0:	00008067          	ret
		return FAILED_FLAG;
    123402c4:	00100513          	li	a0,1
    123402c8:	fc9ff06f          	j	12340290 <flash_smc35x+0x1cc>
			dataOffsetPtr = NandOob16;
    123402cc:	00000b97          	auipc	s7,0x0
    123402d0:	074b8b93          	addi	s7,s7,116 # 12340340 <NandOob16>
			eccDataNums = 3;
    123402d4:	00300b13          	li	s6,3
	if (ecc_num == 1 && dataOffsetPtr != NULL && eccDataNums != 0) {
    123402d8:	00100793          	li	a5,1
    123402dc:	eef81ce3          	bne	a6,a5,123401d4 <flash_smc35x+0x110>
		smc35x_ecc_calculate(ctrl_base, eccData, eccDataNums);
    123402e0:	00010c93          	mv	s9,sp
    123402e4:	000b0613          	mv	a2,s6
    123402e8:	000c8593          	mv	a1,s9
    123402ec:	00090513          	mv	a0,s2
    123402f0:	d21ff0ef          	jal	ra,12340010 <smc35x_ecc_calculate>
    123402f4:	00000793          	li	a5,0
			buffer[dataOffsetPtr[index]] = (~eccData[index]);
    123402f8:	00279713          	slli	a4,a5,0x2
    123402fc:	00fc86b3          	add	a3,s9,a5
    12340300:	00eb8733          	add	a4,s7,a4
    12340304:	00076703          	lwu	a4,0(a4)
    12340308:	0006c683          	lbu	a3,0(a3)
		for(index = 0; index < eccDataNums; index++)
    1234030c:	00178793          	addi	a5,a5,1 # 388001 <_start-0x11fb7fff>
			buffer[dataOffsetPtr[index]] = (~eccData[index]);
    12340310:	00e48733          	add	a4,s1,a4
    12340314:	fff6c693          	not	a3,a3
    12340318:	00d70223          	sb	a3,4(a4)
		for(index = 0; index < eccDataNums; index++)
    1234031c:	0007871b          	sext.w	a4,a5
    12340320:	fd676ce3          	bltu	a4,s6,123402f8 <flash_smc35x+0x234>
    12340324:	eb1ff06f          	j	123401d4 <flash_smc35x+0x110>
