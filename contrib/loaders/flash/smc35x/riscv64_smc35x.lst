
riscv64_smc35x.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000012340000 <_start>:
#endif

		.section .text.entry
		.global _start
_start:
		lla		sp, stack_end
    12340000:	00000117          	auipc	sp,0x0
    12340004:	42810113          	addi	sp,sp,1064 # 12340428 <stack_end>
		jal 	flash_smc35x
    12340008:	0bc000ef          	jal	ra,123400c4 <flash_smc35x>
		ebreak
    1234000c:	00100073          	ebreak

0000000012340010 <smc35x_ecc_calculate>:
static uint32_t __attribute__((aligned(4))) NandOob32[6] = {26, 27, 28, 29, 30, 31};
static uint32_t __attribute__((aligned(4))) NandOob16[3] = {13, 14, 15};		/* data size 512bytes */


int smc35x_ecc_calculate(uint32_t ctrl_base, uint8_t *ecc_data, uint32_t ecc_data_nums)
{
    12340010:	ff010113          	addi	sp,sp,-16
	uint8_t count = 0, status = 0;
	volatile uint8_t ecc_reg = 0;
    12340014:	000107a3          	sb	zero,15(sp)
	uint32_t ecc_value = 0;
	void *ecc_addr = NULL, *status_addr = NULL;

	uint8_t nums = 0;
    12340018:	00000713          	li	a4,0
	while (ecc_data_nums >= 3) {
    1234001c:	00200793          	li	a5,2
    12340020:	02c7ec63          	bltu	a5,a2,12340058 <smc35x_ecc_calculate+0x48>
	}

	/* Check busy signal if it is busy to poll*/
	do {
		// target_read_u8(target, (ctrl_base + SMC_REG_ECC1_STATUS), &status);
        status_addr = (void *)(uintptr_t)(ctrl_base + SMC_REG_ECC1_STATUS);
    12340024:	02051513          	slli	a0,a0,0x20
    12340028:	02055513          	srli	a0,a0,0x20
		status = *(uint8_t *)status_addr;
    1234002c:	40054783          	lbu	a5,1024(a0)
		status &= (1 << SMC_EccStatus_EccStatus_FIELD);
    12340030:	0407f793          	andi	a5,a5,64
	}
	while (status);
    12340034:	00079063          	bnez	a5,12340034 <smc35x_ecc_calculate+0x24>

	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340038:	000107a3          	sb	zero,15(sp)
	{
		// target_read_u32(target, (ctrl_base + SMC_REG_ECC1_BLOCK0 + ecc_reg * 4), &ecc_value);
        ecc_addr = (void *)(uintptr_t)(ctrl_base + SMC_REG_ECC1_BLOCK0);
		ecc_value = *(uint32_t *)ecc_addr;
		// printf("ecc value: %lx", ecc_value);
		if((ecc_value) & (1 << SMC_EccBlock_ISCheakValueValid_FIELD))
    1234003c:	40000637          	lui	a2,0x40000
	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340040:	00f14783          	lbu	a5,15(sp)
    12340044:	0ff7f793          	zext.b	a5,a5
    12340048:	02e7e063          	bltu	a5,a4,12340068 <smc35x_ecc_calculate+0x58>
			// printf("EccInvalidErr");
			return SmcEccDataInvalidErr;
		}
	}

	return ERROR_OK;
    1234004c:	00000513          	li	a0,0
}
    12340050:	01010113          	addi	sp,sp,16
    12340054:	00008067          	ret
		++nums;
    12340058:	0017071b          	addiw	a4,a4,1
    1234005c:	0ff77713          	zext.b	a4,a4
		ecc_data_nums -= 3;
    12340060:	ffd6061b          	addiw	a2,a2,-3
    12340064:	fbdff06f          	j	12340020 <smc35x_ecc_calculate+0x10>
		ecc_value = *(uint32_t *)ecc_addr;
    12340068:	41852783          	lw	a5,1048(a0)
		if((ecc_value) & (1 << SMC_EccBlock_ISCheakValueValid_FIELD))
    1234006c:	00c7f6b3          	and	a3,a5,a2
    12340070:	0006869b          	sext.w	a3,a3
    12340074:	02068863          	beqz	a3,123400a4 <smc35x_ecc_calculate+0x94>
				*ecc_data = ecc_value & 0xFF;
    12340078:	00f58023          	sb	a5,0(a1)
				ecc_value = ecc_value >> 8;
    1234007c:	0087d69b          	srliw	a3,a5,0x8
    12340080:	0107d79b          	srliw	a5,a5,0x10
				*ecc_data = ecc_value & 0xFF;
    12340084:	00f58123          	sb	a5,2(a1)
	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340088:	00f14783          	lbu	a5,15(sp)
				*ecc_data = ecc_value & 0xFF;
    1234008c:	00d580a3          	sb	a3,1(a1)
				++ecc_data;
    12340090:	00358593          	addi	a1,a1,3
	for (ecc_reg = 0; ecc_reg < nums; ++ecc_reg)
    12340094:	00178793          	addi	a5,a5,1
    12340098:	0ff7f793          	zext.b	a5,a5
    1234009c:	00f107a3          	sb	a5,15(sp)
    123400a0:	fa1ff06f          	j	12340040 <smc35x_ecc_calculate+0x30>
			return SmcEccDataInvalidErr;
    123400a4:	01000513          	li	a0,16
    123400a8:	fa9ff06f          	j	12340050 <smc35x_ecc_calculate+0x40>

00000000123400ac <nand_busy>:

uint8_t nand_busy(uint32_t ctrl_base)
{
	uint32_t status = *(volatile uint32_t *)(ctrl_base + SMC_REG_MEMC_STATUS);
    123400ac:	02051513          	slli	a0,a0,0x20
    123400b0:	02055513          	srli	a0,a0,0x20
    123400b4:	00052503          	lw	a0,0(a0)
	status &= (1 << SMC_MemcStatus_SmcInt1RawStatus_FIELD);

	

	if(status)
    123400b8:	00655513          	srli	a0,a0,0x6
		return NAND_READY;
	else
		return NAND_BUSY;
}
    123400bc:	00157513          	andi	a0,a0,1
    123400c0:	00008067          	ret

00000000123400c4 <flash_smc35x>:

int flash_smc35x(uint32_t ctrl_base, uint32_t page_size, void *pbuffer, uint32_t offset, uint32_t count, uint32_t nand_base, uint32_t ecc_num)
{
    123400c4:	f9010113          	addi	sp,sp,-112
    123400c8:	05313423          	sd	s3,72(sp)
    123400cc:	05413023          	sd	s4,64(sp)
    123400d0:	03613823          	sd	s6,48(sp)
    123400d4:	00078993          	mv	s3,a5
    uint32_t oob_size = count - page_size;
	uint32_t eccDataNums = 0, *dataOffsetPtr = NULL;
	uint8_t eccData[12] = {0}, *buffer = pbuffer;
	void *status_addr = NULL;

	void *cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
    123400d8:	3807eb13          	ori	s6,a5,896
	uint32_t cmd_phase_data = -1;
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;

	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    123400dc:	00080a37          	lui	s4,0x80
	void *cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
    123400e0:	020b1b13          	slli	s6,s6,0x20
	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    123400e4:	0149ea33          	or	s4,s3,s4
{
    123400e8:	06113423          	sd	ra,104(sp)
    123400ec:	06813023          	sd	s0,96(sp)
    123400f0:	04913c23          	sd	s1,88(sp)
    123400f4:	05213823          	sd	s2,80(sp)
    123400f8:	03513c23          	sd	s5,56(sp)
    123400fc:	03713423          	sd	s7,40(sp)
    12340100:	03813023          	sd	s8,32(sp)
    12340104:	01913c23          	sd	s9,24(sp)
    12340108:	01a13823          	sd	s10,16(sp)
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
    1234010c:	fff00793          	li	a5,-1
	void *cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_READ_STATUS1 << 3));
    12340110:	020b5b13          	srli	s6,s6,0x20
	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    12340114:	020a1a13          	slli	s4,s4,0x20
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
    12340118:	00fb2023          	sw	a5,0(s6)
	void *data_phase_addr = (void *)(uintptr_t)(nand_base | NAND_DATA_PHASE_FLAG);
    1234011c:	020a5a13          	srli	s4,s4,0x20
	status = *(uint8_t *)data_phase_addr;
	if (!(status & ONFI_STATUS_WP)) {
    12340120:	000a0783          	lb	a5,0(s4) # 80000 <_start-0x122c0000>
	uint8_t eccData[12] = {0}, *buffer = pbuffer;
    12340124:	00013023          	sd	zero,0(sp)
    12340128:	00012423          	sw	zero,8(sp)
	if (!(status & ONFI_STATUS_WP)) {
    1234012c:	0407c063          	bltz	a5,1234016c <flash_smc35x+0xa8>
		return FAILED_FLAG;
    12340130:	00100513          	li	a0,1
	if (!(status & ONFI_STATUS_FAIL)) {
		return FAILED_FLAG;
	}

	return retvel;
    12340134:	06813083          	ld	ra,104(sp)
    12340138:	06013403          	ld	s0,96(sp)
    1234013c:	05813483          	ld	s1,88(sp)
    12340140:	05013903          	ld	s2,80(sp)
    12340144:	04813983          	ld	s3,72(sp)
    12340148:	04013a03          	ld	s4,64(sp)
    1234014c:	03813a83          	ld	s5,56(sp)
    12340150:	03013b03          	ld	s6,48(sp)
    12340154:	02813b83          	ld	s7,40(sp)
    12340158:	02013c03          	ld	s8,32(sp)
    1234015c:	01813c83          	ld	s9,24(sp)
    12340160:	01013d03          	ld	s10,16(sp)
    12340164:	07010113          	addi	sp,sp,112
    12340168:	00008067          	ret
	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_PROGRAM_PAGE_CYCLES << 21) | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (ONFI_CMD_PROGRAM_PAGE1 << 3));
    1234016c:	00a087b7          	lui	a5,0xa08
    12340170:	40078793          	addi	a5,a5,1024 # a08400 <_start-0x11937c00>
    12340174:	00f9e7b3          	or	a5,s3,a5
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340178:	00188cb7          	lui	s9,0x188
	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_PROGRAM_PAGE_CYCLES << 21) | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (ONFI_CMD_PROGRAM_PAGE1 << 3));
    1234017c:	02079793          	slli	a5,a5,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340180:	0199ecb3          	or	s9,s3,s9
	cmd_phase_addr = (void *)(uintptr_t)(nand_base | (ONFI_CMD_PROGRAM_PAGE_CYCLES << 21) | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (ONFI_CMD_PROGRAM_PAGE1 << 3));
    12340184:	0207d793          	srli	a5,a5,0x20
	cmd_phase_data = offset >> (32 - (2*8));
    12340188:	0106d69b          	srliw	a3,a3,0x10
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    1234018c:	020c9c93          	slli	s9,s9,0x20
    *(uint32_t *)cmd_phase_addr = cmd_phase_data;
    12340190:	00d7a023          	sw	a3,0(a5)
    12340194:	00050913          	mv	s2,a0
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340198:	020cdc93          	srli	s9,s9,0x20
	for (index = 0; index < page_size - ONFI_AXI_DATA_WIDTH; ++index)
    1234019c:	00000793          	li	a5,0
	uint32_t flag = 0, retvel = 0;
    123401a0:	00000a93          	li	s5,0
    123401a4:	00000513          	li	a0,0
	for (index = 0; index < page_size - ONFI_AXI_DATA_WIDTH; ++index)
    123401a8:	ffc5869b          	addiw	a3,a1,-4
		if (flag != 2) {
    123401ac:	00200313          	li	t1,2
	for (index = 0; index < page_size - ONFI_AXI_DATA_WIDTH; ++index)
    123401b0:	0007889b          	sext.w	a7,a5
    123401b4:	06d8ec63          	bltu	a7,a3,1234022c <flash_smc35x+0x168>
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (1 << 10));
    123401b8:	001887b7          	lui	a5,0x188
    123401bc:	40078793          	addi	a5,a5,1024 # 188400 <_start-0x121b7c00>
    123401c0:	00f9e7b3          	or	a5,s3,a5
	buffer += page_size - ONFI_AXI_DATA_WIDTH;
    123401c4:	02069693          	slli	a3,a3,0x20
    123401c8:	0206d693          	srli	a3,a3,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (1 << 10));
    123401cc:	02079793          	slli	a5,a5,0x20
	buffer += page_size - ONFI_AXI_DATA_WIDTH;
    123401d0:	00d604b3          	add	s1,a2,a3
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11) | (1 << 10));
    123401d4:	0207d793          	srli	a5,a5,0x20
	buffer += page_size - ONFI_AXI_DATA_WIDTH;
    123401d8:	00000693          	li	a3,0
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    123401dc:	00400613          	li	a2,4
        *(uint8_t *)data_phase_addr = buffer[index];
    123401e0:	00d48533          	add	a0,s1,a3
    123401e4:	00054503          	lbu	a0,0(a0)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    123401e8:	00168693          	addi	a3,a3,1
        *(uint8_t *)data_phase_addr = buffer[index];
    123401ec:	00a78023          	sb	a0,0(a5)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    123401f0:	fec698e3          	bne	a3,a2,123401e0 <flash_smc35x+0x11c>
    uint32_t oob_size = count - page_size;
    123401f4:	40b7043b          	subw	s0,a4,a1
	switch(oob_size)
    123401f8:	04000793          	li	a5,64
    123401fc:	04f40c63          	beq	s0,a5,12340254 <flash_smc35x+0x190>
    12340200:	0487e663          	bltu	a5,s0,1234024c <flash_smc35x+0x188>
    12340204:	01000793          	li	a5,16
    12340208:	0ef40463          	beq	s0,a5,123402f0 <flash_smc35x+0x22c>
    1234020c:	02000793          	li	a5,32
    12340210:	00000c17          	auipc	s8,0x0
    12340214:	140c0c13          	addi	s8,s8,320 # 12340350 <NandOob32>
    12340218:	00600b93          	li	s7,6
    1234021c:	0ef40063          	beq	s0,a5,123402fc <flash_smc35x+0x238>
		smc35x_ecc_calculate(ctrl_base, eccData, eccDataNums);
    12340220:	00000793          	li	a5,0
	for (index = 0; index < oob_size - ONFI_AXI_DATA_WIDTH; ++index)
    12340224:	ffc4041b          	addiw	s0,s0,-4
    12340228:	04c0006f          	j	12340274 <flash_smc35x+0x1b0>
        *(uint8_t *)data_phase_addr = buffer[index];
    1234022c:	00f608b3          	add	a7,a2,a5
    12340230:	0008c883          	lbu	a7,0(a7)
    12340234:	011c8023          	sb	a7,0(s9) # 188000 <_start-0x121b8000>
		if (flag != 2) {
    12340238:	00650663          	beq	a0,t1,12340244 <flash_smc35x+0x180>
			retvel = *(uint8_t *)data_phase_addr;
    1234023c:	00088a9b          	sext.w	s5,a7
			++flag;
    12340240:	0015051b          	addiw	a0,a0,1
	for (index = 0; index < page_size - ONFI_AXI_DATA_WIDTH; ++index)
    12340244:	00178793          	addi	a5,a5,1
    12340248:	f69ff06f          	j	123401b0 <flash_smc35x+0xec>
	switch(oob_size)
    1234024c:	0e000793          	li	a5,224
    12340250:	fcf418e3          	bne	s0,a5,12340220 <flash_smc35x+0x15c>
			dataOffsetPtr = NandOob64;
    12340254:	00000c17          	auipc	s8,0x0
    12340258:	120c0c13          	addi	s8,s8,288 # 12340374 <NandOob64>
			eccDataNums = 12;
    1234025c:	00c00b93          	li	s7,12
    12340260:	09c0006f          	j	123402fc <flash_smc35x+0x238>
        *(uint8_t *)data_phase_addr = buffer[index];
    12340264:	00f48733          	add	a4,s1,a5
    12340268:	00474703          	lbu	a4,4(a4)
    1234026c:	00178793          	addi	a5,a5,1
    12340270:	00ec8023          	sb	a4,0(s9)
	for (index = 0; index < oob_size - ONFI_AXI_DATA_WIDTH; ++index)
    12340274:	0007871b          	sext.w	a4,a5
    12340278:	fe8766e3          	bltu	a4,s0,12340264 <flash_smc35x+0x1a0>
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 21) | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    1234027c:	003887b7          	lui	a5,0x388
    12340280:	00f9e9b3          	or	s3,s3,a5
	buffer += oob_size - ONFI_AXI_DATA_WIDTH;
    12340284:	02041413          	slli	s0,s0,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 21) | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340288:	02099993          	slli	s3,s3,0x20
	buffer += oob_size - ONFI_AXI_DATA_WIDTH;
    1234028c:	02045413          	srli	s0,s0,0x20
	data_phase_addr = (void *)(uintptr_t)(nand_base | (1 << 21) | (1 << 20) | NAND_DATA_PHASE_FLAG | (ONFI_CMD_PROGRAM_PAGE2 << 11));
    12340290:	0209d993          	srli	s3,s3,0x20
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    12340294:	00848433          	add	s0,s1,s0
	buffer += oob_size - ONFI_AXI_DATA_WIDTH;
    12340298:	00400793          	li	a5,4
        *(uint8_t *)data_phase_addr = buffer[index];
    1234029c:	00444703          	lbu	a4,4(s0)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    123402a0:	fff7879b          	addiw	a5,a5,-1
    123402a4:	00140413          	addi	s0,s0,1
        *(uint8_t *)data_phase_addr = buffer[index];
    123402a8:	00e98023          	sb	a4,0(s3)
	for (index = 0; index < ONFI_AXI_DATA_WIDTH; ++index)
    123402ac:	fe0798e3          	bnez	a5,1234029c <flash_smc35x+0x1d8>
	while (nand_busy(ctrl_base) == NAND_BUSY);
    123402b0:	00090513          	mv	a0,s2
    123402b4:	df9ff0ef          	jal	ra,123400ac <nand_busy>
    123402b8:	fe050ce3          	beqz	a0,123402b0 <flash_smc35x+0x1ec>
    status_addr = (void *)(uintptr_t)(ctrl_base + SMC_REG_MEM_CFG_CLR);
    123402bc:	02091913          	slli	s2,s2,0x20
    123402c0:	02095913          	srli	s2,s2,0x20
	status = *(volatile uint32_t *)(ctrl_base + SMC_REG_MEM_CFG_CLR);
    123402c4:	00c92783          	lw	a5,12(s2)
	return retvel;
    123402c8:	000a851b          	sext.w	a0,s5
	status = *(volatile uint32_t *)(ctrl_base + SMC_REG_MEM_CFG_CLR);
    123402cc:	0007879b          	sext.w	a5,a5
    *(volatile uint32_t *)status_addr = status | SMC_MemCfgClr_ClrSmcInt1;
    123402d0:	0107e793          	ori	a5,a5,16
    123402d4:	00f92623          	sw	a5,12(s2)
	*(uint32_t *)cmd_phase_addr = cmd_phase_data;
    123402d8:	fff00793          	li	a5,-1
    123402dc:	00fb2023          	sw	a5,0(s6)
	if (!(status & ONFI_STATUS_FAIL)) {
    123402e0:	000a4783          	lbu	a5,0(s4)
    123402e4:	0017f793          	andi	a5,a5,1
    123402e8:	e40796e3          	bnez	a5,12340134 <flash_smc35x+0x70>
    123402ec:	e45ff06f          	j	12340130 <flash_smc35x+0x6c>
			dataOffsetPtr = NandOob16;
    123402f0:	00000c17          	auipc	s8,0x0
    123402f4:	078c0c13          	addi	s8,s8,120 # 12340368 <NandOob16>
			eccDataNums = 3;
    123402f8:	00300b93          	li	s7,3
	if (ecc_num == 1 && dataOffsetPtr != NULL && eccDataNums != 0) {
    123402fc:	00100793          	li	a5,1
    12340300:	f2f810e3          	bne	a6,a5,12340220 <flash_smc35x+0x15c>
		smc35x_ecc_calculate(ctrl_base, eccData, eccDataNums);
    12340304:	00010d13          	mv	s10,sp
    12340308:	000b8613          	mv	a2,s7
    1234030c:	000d0593          	mv	a1,s10
    12340310:	00090513          	mv	a0,s2
    12340314:	cfdff0ef          	jal	ra,12340010 <smc35x_ecc_calculate>
    12340318:	00000793          	li	a5,0
			buffer[dataOffsetPtr[index]] = (~eccData[index]);
    1234031c:	00279713          	slli	a4,a5,0x2
    12340320:	00fd06b3          	add	a3,s10,a5
    12340324:	00ec0733          	add	a4,s8,a4
    12340328:	00076703          	lwu	a4,0(a4)
    1234032c:	0006c683          	lbu	a3,0(a3)
		for(index = 0; index < eccDataNums; index++)
    12340330:	00178793          	addi	a5,a5,1 # 388001 <_start-0x11fb7fff>
			buffer[dataOffsetPtr[index]] = (~eccData[index]);
    12340334:	00e48733          	add	a4,s1,a4
    12340338:	fff6c693          	not	a3,a3
    1234033c:	00d70223          	sb	a3,4(a4)
		for(index = 0; index < eccDataNums; index++)
    12340340:	0007871b          	sext.w	a4,a5
    12340344:	fd776ce3          	bltu	a4,s7,1234031c <flash_smc35x+0x258>
    12340348:	ed9ff06f          	j	12340220 <flash_smc35x+0x15c>
